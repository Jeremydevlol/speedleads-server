import OpenAI from 'openai';
import { fetchPersonalityInstructions } from '../controllers/personalityController.js';

// Initialize OpenAI client with optimized settings
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 25001, // 25 segundos timeout
  maxRetries: 1,  // Solo 1 reintento para mayor velocidad
});

// Validar variables de entorno cr√≠ticas al inicializar
const validateEnvironment = () => {
  const requiredVars = {
    OPENAI_API_KEY: process.env.OPENAI_API_KEY,
    DEEPSEEK_API_KEY: process.env.DEEPSEEK_API_KEY
  };

  const missingVars = Object.entries(requiredVars)
    .filter(([key, value]) => !value)
    .map(([key]) => key);

  if (missingVars.length > 0) {
    console.error('üö® Variables de entorno faltantes para OpenAI Service:', missingVars);
    if (process.env.NODE_ENV === 'production') {
      console.error('‚ùå No se puede funcionar en producci√≥n sin estas variables');
    }
    return false;
  }
  
  console.log('‚úÖ Variables de entorno de OpenAI validadas correctamente');
  return true;
};

// Validar al cargar el m√≥dulo
const envValid = validateEnvironment();

// Funci√≥n auxiliar para crear una "pausa".
// timeMs debe estar en milisegundos.
function delay(timeMs) {
  return new Promise(resolve => setTimeout(resolve, timeMs));
}

export async function generateBotResponse({ personality, userMessage, userId, history = [], mediaType = null, mediaContent = null }) {
    try {
        // Verificar variables de entorno antes de procesar
        if (!envValid) {
            console.error('‚ùå Variables de entorno no v√°lidas para OpenAI Service');
            console.error('   - OPENAI_API_KEY:', process.env.OPENAI_API_KEY ? 'PRESENTE' : 'FALTANTE');
            console.error('   - DEEPSEEK_API_KEY:', process.env.DEEPSEEK_API_KEY ? 'PRESENTE' : 'FALTANTE');
            return generateSimpleFallbackResponse(userMessage, personality);
        }

        if (!personality || !userMessage) {
            console.error('‚ùå Par√°metros requeridos faltantes:', { 
                personality: !!personality, 
                personalityId: personality?.id,
                userMessage: !!userMessage,
                userMessageLength: userMessage?.length
            });
            return 'Lo siento, no pude procesar tu mensaje. ¬øPodr√≠as intentarlo de nuevo?';
        }

        // Obtener las instrucciones espec√≠ficas de la personalidad
        if (process.env.NODE_ENV !== 'production') console.log(`üîç Obteniendo instrucciones para personalidad ${personality.id} del usuario ${userId}`);
        
        let personalityData;
        try {
            personalityData = await fetchPersonalityInstructions(personality.id, userId);
            console.log('‚úÖ Instrucciones de personalidad obtenidas:', {
                id: personalityData?.id,
                nombre: personalityData?.nombre,
                instruccionesLength: personalityData?.instrucciones?.length || 0,
                instruccionesPreview: personalityData?.instrucciones?.substring(0, 100) + '...'
            });
        } catch (fetchError) {
            console.error('‚ùå Error al obtener instrucciones de personalidad:', fetchError);
            console.error('   - PersonalityId:', personality.id);
            console.error('   - UserId:', userId);
            console.error('   - Stack:', fetchError.stack);
            
            // Usar datos b√°sicos de la personalidad como fallback
            personalityData = {
                id: personality.id,
                nombre: personality.nombre || 'Asistente',
                empresa: personality.empresa || '',
                instrucciones: personality.instrucciones || 'Soy un asistente √∫til y amigable.',
                saludo: personality.saludo || '',
                category: personality.category || 'formal'
            };
            console.log('‚ö†Ô∏è Usando datos b√°sicos de personalidad como fallback');
        }

        // Verificar que tenemos instrucciones v√°lidas
        if (!personalityData || !personalityData.instrucciones) {
            console.error('‚ùå No se pudieron obtener instrucciones v√°lidas para la personalidad');
            console.error('   - PersonalityData:', personalityData);
            return 'Lo siento, hay un problema con la configuraci√≥n de mi personalidad. ¬øPuedes contactar al administrador?';
        }

        // Analizar el contexto de la conversaci√≥n (OPTIMIZADO - usar contexto completo)
        const conversationContext = analyzeConversationContext(history.slice(-20), userMessage); // √öltimos 20 mensajes para contexto completo
        const currentTopic = conversationContext.currentTopic;
        const hasGreeted = conversationContext.hasGreeted;

        // Construir el historial de mensajes para el contexto (OPTIMIZADO PARA CONTEXTO COMPLETO)
        // Usar hasta 50 mensajes para mantener contexto completo de toda la conversaci√≥n
        const initialHistory = history.slice(-50).map(msg => ({  
            role: msg.role || 'assistant', // Usar role directamente, fallback a assistant
            content: msg.content || msg.text_content || '', // Leer tanto content como text_content
            // Agregar contexto temporal para mejor memoria
            timestamp: msg.timestamp || msg.whatsapp_created_at || msg.created_at,
            position: msg.position || 0,
            isRecent: msg.isRecent || false,
            // Mantener compatibilidad con sender_type para funciones que lo necesiten
            sender_type: msg.sender_type || (msg.role === 'user' ? 'user' : msg.role === 'system' ? 'system' : 'ia')
        }));

        // Analizar el historial completo para encontrar contenido multimedia relevante
        const recentMultimediaContent = initialHistory
            .filter(msg => msg.content && (
                msg.content.includes('[Contenido de imagen:') ||
                msg.content.includes('[Audio transcrito:') ||
                msg.content.includes('[Contenido de PDF:') ||
                msg.content.includes('[Contenido de documento Word:') ||
                msg.content.includes('[Contenido multimedia:')
            ))
            .slice(-8); // √öltimos 8 mensajes con multimedia para mejor contexto

        // Ajustar el historial seg√∫n si hay multimedia y contexto
        // Usar hasta 50 mensajes para mantener contexto completo
        const historyLimit = recentMultimediaContent.length > 0 ? 50 : 50;
        const messageHistory = initialHistory.slice(-historyLimit);

        console.log(`üß† Historial optimizado: ${messageHistory.length} mensajes (${recentMultimediaContent.length} con multimedia)`);
        
        // Log detallado para verificar que TODOS los mensajes se lean correctamente
        console.log(`üìñ VERIFICANDO LECTURA COMPLETA DE MENSAJES:`);
        messageHistory.forEach((msg, index) => {
            console.log(`   ${index + 1}. [${msg.role}] ${msg.content.substring(0, 100)}${msg.content.length > 100 ? '...' : ''}`);
        });

        // Detectar si hay contenido multimedia en el historial
        const hasSystemMessages = history.some(msg => msg.role === 'system' || msg.sender_type === 'system');
        const hasExtractedContent = history.some(msg => 
            (msg.role === 'system' || msg.sender_type === 'system') && 
            (msg.content?.length > 50 || msg.text_content?.length > 50)
        );

        // Determinar si el mensaje es sobre multimedia
        const isMediaMessage = mediaType || 
            userMessage.includes('Analiza la imagen') ||
            userMessage.includes('Analiza el pdf') || 
            userMessage.includes('Analiza el PDF') ||
            userMessage.includes('Analiza el documento') ||
            userMessage.includes('imagen adjunta') || 
            userMessage.includes('pdf adjunto') ||
            userMessage.includes('documento adjunto') ||
            userMessage.includes('Final de la imagen') ||
            userMessage.includes('Final del PDF') ||
            userMessage.includes('Final del documento Word') ||
            userMessage.includes('Final del audio') ||
            userMessage.includes('Audio recibido pero') ||
            userMessage.includes('Audio procesado pero') ||
            userMessage.includes('[Contenido de imagen:') ||
            userMessage.includes('[Contenido de PDF:') ||
            userMessage.includes('[Contenido de documento Word:') ||
            userMessage.includes('[Audio transcrito:') ||
            userMessage.includes('[Contenido multimedia:') ||
            hasSystemMessages;
        
        // Construir contexto espec√≠fico mejorado para multimedia (MEJORADO PARA MANTENER CONTEXTO)
        let mediaPrompt = '';
        
        if (isMediaMessage) {
            // Detectar el tipo espec√≠fico de media
            if (userMessage.includes('Audio recibido pero') || userMessage.includes('Audio procesado pero')) {
                mediaPrompt = `\n\nüéµ AUDIO NO TRANSCRITO: El usuario envi√≥ un audio pero no se pudo procesar correctamente. Reconoce que recibiste el audio, explica brevemente por qu√© no se pudo procesar (sin detalles t√©cnicos), y pregunta si puede escribir el mensaje o enviar el audio de otra forma.`;
            } else if (userMessage.includes('[Audio transcrito:') || userMessage.includes('Final del audio')) {
                // Audio transcrito exitosamente
                mediaPrompt = `\n\nüéµ AUDIO TRANSCRITO: El usuario envi√≥ un audio que fue transcrito exitosamente. El contenido transcrito est√° incluido en el mensaje. Responde directamente sobre el contenido del audio como si el usuario te hubiera escrito ese texto. NO menciones que es un audio - simplemente responde al contenido.`;
            } else if (userMessage.includes('[Contenido de imagen:') || userMessage.includes('Final de la imagen')) {
                // Imagen procesada
                mediaPrompt = `\n\nüñºÔ∏è IMAGEN ANALIZADA: El usuario envi√≥ una imagen que fue analizada exitosamente. El contenido extra√≠do de la imagen est√° incluido en el mensaje. Responde espec√≠ficamente sobre lo que ves en la imagen bas√°ndote en el contenido extra√≠do. Puedes hacer an√°lisis, observaciones o responder preguntas sobre la imagen.`;
            } else if (userMessage.includes('[Contenido de PDF:') || userMessage.includes('Final del PDF')) {
                // PDF procesado
                mediaPrompt = `\n\nüìÑ PDF ANALIZADO: El usuario envi√≥ un documento PDF que fue procesado exitosamente. El contenido extra√≠do del PDF est√° incluido en el mensaje. Responde espec√≠ficamente sobre el contenido del documento, puedes hacer an√°lisis, res√∫menes o responder preguntas sobre el PDF.`;
            } else if (userMessage.includes('[Contenido de documento Word:') || userMessage.includes('Final del documento Word')) {
                // Documento Word procesado
                mediaPrompt = `\n\nüìù DOCUMENTO WORD ANALIZADO: El usuario envi√≥ un documento Word (.docx) que fue procesado exitosamente. El contenido extra√≠do del documento est√° incluido en el mensaje. Responde espec√≠ficamente sobre el contenido del documento, puedes hacer an√°lisis, res√∫menes o responder preguntas sobre el documento Word.`;
            } else if (userMessage.includes('[Contenido multimedia:')) {
                // Multimedia gen√©rico
                mediaPrompt = `\n\nüìé MULTIMEDIA PROCESADO: El usuario envi√≥ contenido multimedia que fue procesado exitosamente. El contenido extra√≠do est√° incluido en el mensaje. Responde espec√≠ficamente sobre ese contenido.`;
            } else if (hasExtractedContent) {
                mediaPrompt = `\n\nüìé CONTENIDO MULTIMEDIA: Tienes acceso al contenido extra√≠do de archivos (im√°genes, PDFs, audios, documentos Word) en los mensajes del sistema del historial. √ösalo para responder espec√≠ficamente sobre ese contenido. NO digas que no tienes acceso - S√ç tienes el contenido extra√≠do.`;
            } else {
                mediaPrompt = `\n\nüìé MULTIMEDIA: El usuario envi√≥ archivos. Analiza el contenido que se te proporciona en el historial.`;
            }
        }
        
        // NUEVO: Agregar contexto de multimedia reciente si existe
        if (recentMultimediaContent.length > 0 && !isMediaMessage) {
            // Si el usuario hace una pregunta que podr√≠a relacionarse con multimedia anterior
            const questionKeywords = ['quien', 'que', 'como', 'donde', 'cuando', 'por que', 'dime', 'explica', 'analiza'];
            const hasQuestion = questionKeywords.some(keyword => 
                userMessage.toLowerCase().includes(keyword)
            );
            
            if (hasQuestion) {
                mediaPrompt = `\n\nüîó CONTEXTO MULTIMEDIA RECIENTE: En los mensajes anteriores se comparti√≥ contenido multimedia (im√°genes, audios, documentos). Si la pregunta actual se relaciona con ese contenido, √∫salo para responder. El contenido est√° disponible en el historial de la conversaci√≥n.`;
            }
        }

        // Construir el prompt del sistema OPTIMIZADO (MEJORADO PARA CONTEXTO COMPLETO)
        const systemPrompt = `Eres ${personalityData.nombre}. ${personalityData.empresa ? `Trabajas en ${personalityData.empresa}` : ''}

PERSONALIDAD: ${personalityData.instrucciones}

INSTRUCCIONES CR√çTICAS PARA CONTEXTO COMPLETO:
- ‚ö†Ô∏è DEBES LEER Y ANALIZAR TODOS los mensajes del historial que se te proporcionan
- ‚ö†Ô∏è NO ignores ning√∫n mensaje anterior - cada uno contiene informaci√≥n importante
- ‚ö†Ô∏è Si el usuario pregunta sobre algo mencionado antes, DEBES recordarlo y responder bas√°ndote en esa informaci√≥n
- ‚ö†Ô∏è Conecta TODA la conversaci√≥n anterior con la pregunta actual
- ‚ö†Ô∏è Si hay informaci√≥n en mensajes anteriores (im√°genes, audios, documentos), √öSALA para responder
- ‚ö†Ô∏è NO digas que no tienes acceso a informaci√≥n que est√° en el historial de la conversaci√≥n
- ‚ö†Ô∏è Mant√©n el contexto COMPLETO de toda la conversaci√≥n

${hasGreeted ? 'Ya saludaste, no vuelvas a saludar.' : ''}
${mediaPrompt}

Responde en el mismo idioma que el usuario y sigue tu personalidad exactamente.`;

        // Construir el array de mensajes para la API
        const messages = [
            { role: 'system', content: systemPrompt },
            ...messageHistory,
            { role: 'user', content: userMessage }
        ];

        console.log('üì§ Enviando a OpenAI:', {
            totalMessages: messages.length,
            systemPromptLength: systemPrompt.length,
            personalityInstructions: personalityData.instrucciones?.length || 0,
            finalUserMessage: userMessage.substring(0, 100) + (userMessage.length > 100 ? '...' : ''),
            hasSystemMessages: messages.filter(m => m.role === 'system').length,
            mediaPrompt: mediaPrompt ? mediaPrompt.substring(0, 200) + '...' : 'none',
            recentMultimediaCount: recentMultimediaContent.length,
            historyLength: messageHistory.length
        });

        // Intentar primero con OpenAI (OPTIMIZADO)
        try {
            console.log('üöÄ Intentando con OpenAI...');
            const completion = await openai.chat.completions.create({
                model: 'gpt-4o-mini', // Modelo m√°s r√°pido
                messages,
                temperature: 0.7,
                max_tokens: 1500, // Aumentado para respuestas completas
                stream: false
            });

            if (!completion.choices?.[0]?.message?.content) {
                throw new Error('Respuesta de OpenAI inv√°lida');
            }

            console.log('‚úÖ Respuesta exitosa de OpenAI');
            return completion.choices[0].message.content;
        } catch (openaiError) {
            console.error('‚ùå Error con OpenAI:', {
                message: openaiError.message,
                code: openaiError.code,
                type: openaiError.type,
                status: openaiError.status
            });
            
            // Si falla OpenAI, intentar con DeepSeek (OPTIMIZADO)
            try {
                console.log('üîÑ Intentando con DeepSeek como respaldo...');
                
                const deepseekResponse = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat', // Modelo m√°s r√°pido
                        messages,
                        temperature: 0.7,
                        max_tokens: 1500, // Aumentado para respuestas completas
                        stream: false
                    }),
                    signal: AbortSignal.timeout(15001) // 15 segundos timeout
                });

                if (!deepseekResponse.ok) {
                    const errorText = await deepseekResponse.text();
                    throw new Error(`Error en DeepSeek: ${deepseekResponse.status} - ${errorText}`);
                }

                const deepseekData = await deepseekResponse.json();
                console.log('‚úÖ Respuesta exitosa de DeepSeek');
                
                return deepseekData.choices[0].message.content || 
                       'Lo siento, no pude generar una respuesta adecuada.';
                
            } catch (deepseekError) {
                console.error('‚ùå Error con DeepSeek:', {
                    message: deepseekError.message,
                    stack: deepseekError.stack
                });
                
                // Si ambos fallan, generar una respuesta simple
                console.log('‚ö†Ô∏è Usando respuesta de fallback - ambos servicios fallaron');
                return generateSimpleFallbackResponse(userMessage, personalityData);
            }
        }
    } catch (error) {
        console.error('‚ùå Error general en generateBotResponse:', {
            message: error.message,
            stack: error.stack,
            personalityId: personality?.id,
            userId,
            userMessageLength: userMessage?.length
        });
        return 'Lo siento, hubo un error al procesar tu mensaje. ¬øPodr√≠as intentarlo de nuevo?';
    }
}

// OPTIMIZADO - An√°lisis de contexto MEJORADO para CONTEXTO COMPLETO
function analyzeConversationContext(history, currentMessage) {
    // Usar hasta 20 mensajes para mantener contexto completo
    const recentMessages = history.slice(-20); // √öltimos 20 mensajes para contexto completo
    
    // Detectar saludo simple
    const hasGreeted = recentMessages.some(msg => {
        const content = msg.content || '';
        return content.toLowerCase().includes('hola') || 
               content.toLowerCase().includes('buenos') || 
               content.toLowerCase().includes('buenas');
    });

    // Extraer tema principal con an√°lisis mejorado
    const currentTopic = extractEnhancedTopic(recentMessages.concat([{content: currentMessage}]));
    
    // Analizar preguntas previas para mejor contexto
    const previousQuestions = extractPreviousQuestions(recentMessages);
    
    // Analizar contexto de medios para mejor memoria
    const mediaContext = analyzeMediaContext(recentMessages);
    
    // Detectar continuidad de conversaci√≥n
    const conversationContinuity = analyzeConversationContinuity(recentMessages, currentMessage);

    return {
        currentTopic,
        hasGreeted,
        previousQuestions,
        lastBotMessage: recentMessages[recentMessages.length - 1]?.content || '',
        mediaContext,
        lastMediaType: mediaContext?.type || null,
        conversationContinuity,
        contextStrength: recentMessages.length // Fuerza del contexto basada en cantidad de mensajes
    };
}

// NUEVO - Extracci√≥n de tema simplificada
function extractSimpleTopic(messages) {
    const text = messages.map(m => m.content || m.text_content || '').join(' ').toLowerCase();
    
    // Palabras clave simples
    if (text.includes('precio') || text.includes('costo') || text.includes('pagar')) return 'precios';
    if (text.includes('producto') || text.includes('servicio')) return 'productos';
    if (text.includes('ayuda') || text.includes('problema')) return 'soporte';
    
    return null;
}

// MEJORADO - Extracci√≥n de tema con an√°lisis avanzado
function extractEnhancedTopic(messages) {
    const text = messages.map(m => m.content || '').join(' ').toLowerCase();
    
    // Palabras clave extendidas para mejor contexto
    if (text.includes('precio') || text.includes('costo') || text.includes('pagar') || text.includes('euros') || text.includes('‚Ç¨')) return 'precios';
    if (text.includes('producto') || text.includes('servicio') || text.includes('coche') || text.includes('auto') || text.includes('veh√≠culo') || text.includes('berlina')) return 'productos';
    if (text.includes('ayuda') || text.includes('problema') || text.includes('soporte') || text.includes('duda')) return 'soporte';
    if (text.includes('informaci√≥n') || text.includes('detalles') || text.includes('caracter√≠sticas')) return 'informaci√≥n';
    if (text.includes('contacto') || text.includes('llamar') || text.includes('visitar')) return 'contacto';
    if (text.includes('horario') || text.includes('disponibilidad') || text.includes('cuando')) return 'horarios';
    if (text.includes('audi') || text.includes('bmw') || text.includes('ford') || text.includes('mercedes')) return 'marcas_coches';
    if (text.includes('camaro') || text.includes('muscle') || text.includes('deportivo')) return 'coches_deportivos';
    
    return null;
}

// NUEVA - Extraer preguntas previas para mejor contexto
function extractPreviousQuestions(messages) {
    const questions = [];
    const questionKeywords = ['qu√©', 'quien', 'c√≥mo', 'd√≥nde', 'cu√°ndo', 'por qu√©', 'cu√°l', 'dime', 'explica', 'analiza'];
    
    messages.forEach(msg => {
        const content = msg.content || '';
        if (questionKeywords.some(keyword => content.toLowerCase().includes(keyword))) {
            questions.push(content.substring(0, 100));
        }
    });
    
    return questions.slice(-5); // √öltimas 5 preguntas para mejor contexto
}

// NUEVA - Analizar contexto de medios para mejor memoria
function analyzeMediaContext(messages) {
    const mediaMessages = messages.filter(msg => {
        const content = msg.content || msg.text_content || '';
        return content.includes('[Contenido de') || content.includes('Final del') || content.includes('Audio transcrito');
    });
    
    if (mediaMessages.length === 0) return null;
    
    const lastMedia = mediaMessages[mediaMessages.length - 1];
    let type = 'multimedia';
    
    if (lastMedia.content.includes('imagen')) type = 'imagen';
    else if (lastMedia.content.includes('PDF')) type = 'pdf';
    else if (lastMedia.content.includes('audio')) type = 'audio';
    else if (lastMedia.content.includes('documento')) type = 'documento';
    
    return {
        type,
        content: lastMedia.content,
        timestamp: lastMedia.timestamp || lastMedia.whatsapp_created_at
    };
}

// NUEVA - Analizar continuidad de conversaci√≥n
function analyzeConversationContinuity(messages, currentMessage) {
    if (messages.length < 2) return 'nueva';
    
    const lastMessage = messages[messages.length - 1];
    const lastContent = lastMessage.content || lastMessage.text_content || '';
    const currentContent = currentMessage || '';
    
    // Detectar si es continuaci√≥n del tema anterior
    const commonWords = findCommonWords(lastContent, currentContent);
    const isContinuation = commonWords.length > 0;
    
    return {
        type: isContinuation ? 'continuaci√≥n' : 'nuevo_tema',
        commonWords,
        strength: commonWords.length
    };
}

// NUEVA - Encontrar palabras comunes entre mensajes
function findCommonWords(text1, text2) {
    const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 3);
    const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 3);
    
    return words1.filter(word => words2.includes(word));
}

function generateSimpleFallbackResponse(userMessage, personalityData) {
    const responses = [
        'Disculpa la demora. ¬øPodr√≠as repetir tu pregunta?',
        'Tengo algunos problemas t√©cnicos. ¬øEn qu√© puedo ayudarte?',
        'Lo siento, no pude procesar tu mensaje correctamente. ¬øPuedes intentar de nuevo?'
    ];
    
    return responses[Math.floor(Math.random() * responses.length)];
}

function extractTopic(messages) {
  // Implementar l√≥gica para extraer el tema principal de los √∫ltimos mensajes
  const topics = new Map();
  
  messages.forEach(msg => {
    const words = msg.content.toLowerCase().split(/\s+/);
    words.forEach(word => {
      if (word.length > 3) { // Ignorar palabras muy cortas
        topics.set(word, (topics.get(word) || 0) + 1);
      }
    });
  });

  // Retornar el tema m√°s frecuente
  let maxCount = 0;
  let mainTopic = null;
  topics.forEach((count, topic) => {
    if (count > maxCount) {
      maxCount = count;
      mainTopic = topic;
    }
  });

  return mainTopic;
}

function processMessageInContext(message, context) {
  let processedMessage = message;

  // Si hay contexto de medio, a√±adirlo al mensaje
  if (context.mediaContext) {
    processedMessage = `[Contexto anterior: ${context.mediaContext}] ${message}`;
  }

  // Si hay un tema actual, a√±adirlo al contexto
  if (context.currentTopic) {
    processedMessage = `[Tema actual: ${context.currentTopic}] ${processedMessage}`;
  }

  return processedMessage;
}

function buildContextualHistory(history, context) {
  return history
    .filter((msg, index, self) => 
      index === 0 || 
      (msg.text_content && msg.text_content !== self[index - 1].text_content)
    )
    .slice(-5)
    .map(m => ({
      role: m.sender_type === 'user' ? 'user' : 'assistant',
      content: m.text_content || ''
    }))
    .filter(m => m.content.trim() !== '');
}

function buildSystemPrompt(p, instructions, userId, hasGreeted, currentTopic, previousQuestions) {
  const baseInstr = Array.isArray(p.instrucciones)
    ? p.instrucciones.join('\n')
    : p.instrucciones;
  const compInstr = instructions.length
    ? instructions.join('\n')
    : '';

  const contextInfo = currentTopic 
    ? `\nTema actual de la conversaci√≥n: ${currentTopic}`
    : '';
  const questionsInfo = previousQuestions.length > 0
    ? `\nPreguntas anteriores:\n${previousQuestions.slice(-3).join('\n')}`
    : '';

  return `
  # Configuraci√≥n de Personalidad
  Nombre: ${p.nombre}
  Categor√≠a: ${p.category}
  ${p.empresa ? `Empresa: ${p.empresa}` : ''}
  ${p.posicion ? `Posici√≥n: ${p.posicion}` : ''}
  ${p.sitio_web ? `Sitio Web: ${p.sitio_web}` : ''}
  ${p.saludo && p.saludo.trim() !== '' ? `Saludo espec√≠fico: ${p.saludo}` : 'Sin saludo predefinido'}
  
  # Contexto
  ${p.context}
  ${contextInfo}
  ${questionsInfo}
  
  # Instrucciones Base
  ${baseInstr}
  
  # Instrucciones Complementarias
  ${compInstr}
  
  # Directrices Generales
  - ${hasGreeted ? 'Ya se ha saludado al usuario, no uses ning√∫n saludo.' : (p.saludo && p.saludo.trim() !== '' ? 'Usa el saludo espec√≠fico solo en la primera respuesta o cuando te hagan un saludo.' : 'NO generes saludos autom√°ticos - responde directamente a lo que te pregunten.')}
  - Mant√©n el estilo propio de la categor√≠a: **${p.category}**.
  - Responde en el mismo idioma que el usuario.
  - S√© claro y directo, pero acorde a tu rol.
  - No menciones que eres una IA.
  - Mant√©n el contexto de la conversaci√≥n, incluyendo referencias a mensajes anteriores.
  - Si el usuario env√≠a un medio (imagen, audio, documento), considera el contexto de la conversaci√≥n al responder.
  - Mant√©n la coherencia en las respuestas bas√°ndote en el tema actual de la conversaci√≥n.
  - Considera las preguntas anteriores al generar respuestas.
  - Usuario: ${userId}.
  `;
}

/**
 * Transcribe un buffer de audio usando Whisper de OpenAI (OPTIMIZADO v5 - Con retry)
 */
/**
 * Procesa y mejora texto extra√≠do de PDFs usando IA para crear mejores instrucciones
 * @param {string} extractedText - Texto extra√≠do del PDF
 * @param {string} personalityName - Nombre de la personalidad
 * @param {string} personalityCategory - Categor√≠a de la personalidad
 * @returns {Promise<string>} - Instrucciones mejoradas y estructuradas
 */
export async function processInstructionsWithAI(extractedText, personalityName = 'Asistente', personalityCategory = 'formal') {
  const startTime = Date.now();
  const processingId = `ai-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  
  try {
    console.log(`ü§ñ [${processingId}] Iniciando procesamiento IA para ${personalityName} (${personalityCategory})`);
    console.log(`üìÑ [${processingId}] Texto original: ${extractedText.length} caracteres`);
    console.log(`üîç [${processingId}] Preview: ${extractedText.substring(0, 150)}...`);
    
    if (!extractedText || extractedText.trim().length < 10) {
      throw new Error('Texto extra√≠do insuficiente para procesar');
    }

    // Verificar variables de entorno
    if (!envValid) {
      console.error('‚ùå Variables de entorno no v√°lidas para procesamiento IA');
      return extractedText; // Retornar texto original si no hay IA disponible
    }

    // Construir prompt especializado para mejorar instrucciones
    const improvementPrompt = `Eres un experto en crear instrucciones para chatbots de IA. Tu tarea es tomar el texto extra√≠do de un PDF y convertirlo en instrucciones claras, estructuradas y efectivas para un chatbot llamado "${personalityName}" de categor√≠a "${personalityCategory}".

REQUISITOS CR√çTICOS:
- ‚úÖ MANT√âN TODA la informaci√≥n del texto original - NO elimines nada importante
- ‚úÖ ESTRUCTURA el contenido de manera clara y organizada
- ‚úÖ CONVIERTE la informaci√≥n en instrucciones directas y accionables
- ‚úÖ USA un lenguaje claro y profesional
- ‚úÖ ORGANIZA por secciones l√≥gicas si es necesario
- ‚úÖ MANT√âN el contexto y los detalles espec√≠ficos
- ‚úÖ ADAPTA el tono a la categor√≠a: ${personalityCategory}

CATEGOR√çAS DE PERSONALIDAD:
- formal: Lenguaje profesional y respetuoso
- amigable: Tono cercano pero profesional
- familia: Tono c√°lido y familiar
- negocios: Enfoque empresarial y directo

FORMATO DE SALIDA:
Estructura las instrucciones de manera clara, usando:
- P√°rrafos bien organizados
- Listas cuando sea apropiado
- Secciones tem√°ticas si el contenido lo requiere
- Instrucciones espec√≠ficas sobre c√≥mo responder
- Informaci√≥n clave que debe recordar

TEXTO ORIGINAL A PROCESAR:
${extractedText}

INSTRUCCIONES MEJORADAS:`;

    const messages = [
      { role: 'system', content: 'Eres un experto en optimizaci√≥n de instrucciones para chatbots. Tu objetivo es mejorar y estructurar instrucciones manteniendo toda la informaci√≥n original.' },
      { role: 'user', content: improvementPrompt }
    ];

    console.log('üöÄ Enviando a OpenAI para procesamiento de instrucciones...');
    
    // Intentar con OpenAI primero
    try {
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages,
        temperature: 0.3, // Temperatura baja para mayor consistencia
        max_tokens: 2000, // Suficiente para instrucciones detalladas
        stream: false
      });

      if (!completion.choices?.[0]?.message?.content) {
        throw new Error('Respuesta de OpenAI inv√°lida para procesamiento de instrucciones');
      }

      const improvedInstructions = completion.choices[0].message.content.trim();
      const processingTime = Date.now() - startTime;
      const improvementRatio = (improvedInstructions.length / extractedText.length).toFixed(2);
      
      console.log(`‚úÖ [${processingId}] Instrucciones mejoradas con OpenAI:`);
      console.log(`   - Tiempo de procesamiento: ${processingTime}ms`);
      console.log(`   - Caracteres originales: ${extractedText.length}`);
      console.log(`   - Caracteres mejorados: ${improvedInstructions.length}`);
      console.log(`   - Ratio de mejora: ${improvementRatio}x`);
      console.log(`   - Tokens utilizados: ~${Math.ceil((extractedText.length + improvedInstructions.length) / 4)}`);
      
      // Log de calidad
      logProcessingQuality(processingId, {
        originalLength: extractedText.length,
        improvedLength: improvedInstructions.length,
        processingTime,
        provider: 'OpenAI',
        personalityName,
        personalityCategory,
        success: true
      });
      
      return improvedInstructions;
      
    } catch (openaiError) {
      console.error('‚ùå Error con OpenAI en procesamiento de instrucciones:', openaiError.message);
      
      // Fallback a DeepSeek
      try {
        console.log('üîÑ Intentando con DeepSeek para procesamiento de instrucciones...');
        
        const deepseekResponse = await fetch('https://api.deepseek.com/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`
          },
          body: JSON.stringify({
            model: 'deepseek-chat',
            messages,
            temperature: 0.3,
            max_tokens: 2000,
            stream: false
          }),
          signal: AbortSignal.timeout(20000) // 20 segundos timeout
        });

        if (!deepseekResponse.ok) {
          const errorText = await deepseekResponse.text();
          throw new Error(`Error en DeepSeek: ${deepseekResponse.status} - ${errorText}`);
        }

        const deepseekData = await deepseekResponse.json();
        const improvedInstructions = deepseekData.choices[0].message.content?.trim();
        
        if (!improvedInstructions) {
          throw new Error('Respuesta vac√≠a de DeepSeek');
        }
        
        const processingTime = Date.now() - startTime;
        const improvementRatio = (improvedInstructions.length / extractedText.length).toFixed(2);
        
        console.log(`‚úÖ [${processingId}] Instrucciones mejoradas con DeepSeek:`);
        console.log(`   - Tiempo de procesamiento: ${processingTime}ms`);
        console.log(`   - Ratio de mejora: ${improvementRatio}x`);
        
        // Log de calidad
        logProcessingQuality(processingId, {
          originalLength: extractedText.length,
          improvedLength: improvedInstructions.length,
          processingTime,
          provider: 'DeepSeek',
          personalityName,
          personalityCategory,
          success: true
        });
        
        return improvedInstructions;
        
      } catch (deepseekError) {
        console.error('‚ùå Error con DeepSeek en procesamiento de instrucciones:', deepseekError.message);
        
        // Si ambos fallan, retornar texto original con formato b√°sico
        console.log(`‚ö†Ô∏è [${processingId}] Usando formato b√°sico - ambos servicios IA fallaron`);
        
        const basicInstructions = formatInstructionsBasic(extractedText, personalityName, personalityCategory);
        const processingTime = Date.now() - startTime;
        
        // Log de fallback
        logProcessingQuality(processingId, {
          originalLength: extractedText.length,
          improvedLength: basicInstructions.length,
          processingTime,
          provider: 'Fallback',
          personalityName,
          personalityCategory,
          success: false,
          error: 'Both AI services failed'
        });
        
        return basicInstructions;
      }
    }
    
  } catch (error) {
    const processingTime = Date.now() - startTime;
    console.error(`‚ùå [${processingId}] Error general en processInstructionsWithAI:`, error.message);
    
    // Log de error
    logProcessingQuality(processingId, {
      originalLength: extractedText.length,
      improvedLength: extractedText.length,
      processingTime,
      provider: 'Error',
      personalityName,
      personalityCategory,
      success: false,
      error: error.message
    });
    
    // En caso de error, retornar el texto original
    return extractedText;
  }
}

/**
 * Registra m√©tricas de calidad del procesamiento IA
 */
function logProcessingQuality(processingId, metrics) {
  const logEntry = {
    id: processingId,
    timestamp: new Date().toISOString(),
    ...metrics,
    improvementRatio: (metrics.improvedLength / metrics.originalLength).toFixed(2),
    efficiency: metrics.processingTime > 0 ? (metrics.improvedLength / metrics.processingTime).toFixed(2) : 0
  };
  
  console.log(`üìä [${processingId}] M√©tricas de calidad:`, JSON.stringify(logEntry, null, 2));
  
  // Aqu√≠ se podr√≠a enviar a un sistema de monitoreo como DataDog, New Relic, etc.
  // await sendToMonitoring(logEntry);
}

/**
 * Formato b√°sico de instrucciones cuando la IA no est√° disponible
 */
function formatInstructionsBasic(text, personalityName, category) {
  const categoryIntro = {
    formal: `Como ${personalityName}, debes mantener un tono profesional y respetuoso.`,
    amigable: `Como ${personalityName}, debes ser cercano y amigable en tus respuestas.`,
    familia: `Como ${personalityName}, debes usar un tono c√°lido y familiar.`,
    negocios: `Como ${personalityName}, debes enfocarte en aspectos empresariales y ser directo.`
  };

  return `${categoryIntro[category] || categoryIntro.formal}

INSTRUCCIONES BASADAS EN EL DOCUMENTO:

${text}

Recuerda seguir estas instrucciones en todas tus respuestas y mantener la informaci√≥n proporcionada.

NOTA: Estas instrucciones fueron procesadas autom√°ticamente desde un documento PDF.`;
}

/**
 * Reprocesa instrucciones existentes con IA para mejorarlas
 * @param {string} existingInstructions - Instrucciones existentes
 * @param {string} personalityName - Nombre de la personalidad
 * @param {string} personalityCategory - Categor√≠a de la personalidad
 * @returns {Promise<string>} - Instrucciones mejoradas
 */
export async function reprocessExistingInstructions(existingInstructions, personalityName, personalityCategory) {
  console.log(`üîÑ Reprocesando instrucciones existentes para ${personalityName}...`);
  
  if (!existingInstructions || existingInstructions.trim().length < 20) {
    throw new Error('Instrucciones existentes insuficientes para reprocesar');
  }
  
  // Usar la misma funci√≥n pero con un prompt ligeramente diferente
  return await processInstructionsWithAI(existingInstructions, personalityName, personalityCategory);
}

export async function transcribeAudioBuffer(audioBuffer, filename = 'audio.ogg') {
  if (!Buffer.isBuffer(audioBuffer)) {
    throw new Error('Buffer de audio inv√°lido');
  }

  // Verificar tama√±o del buffer (l√≠mite de 25MB para Whisper)
  if (audioBuffer.length > 25 * 1024 * 1024) {
    throw new Error('El archivo de audio es demasiado grande (m√°ximo 25MB)');
  }

  let retries = 3;
  let lastError;

  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      console.log(`üéµ Intentando transcribir audio (intento ${attempt}/${retries})...`);
      
      const transcription = await openai.audio.transcriptions.create({
        file: new File([audioBuffer], filename),
        model: 'whisper-1',
        response_format: 'text',
        language: 'es' // Especificar idioma para mayor velocidad
      });

      if (!transcription) throw new Error('La respuesta de Whisper est√° vac√≠a');
      
      console.log(`‚úÖ Audio transcrito exitosamente en intento ${attempt}`);
      return transcription;
      
    } catch (err) {
      lastError = err;
      console.error(`‚ùå Error en Whisper API (intento ${attempt}):`, {
        message: err.message,
        status: err.status,
        type: err.type,
        code: err.code
      });

      // Si es el √∫ltimo intento, lanzar el error
      if (attempt === retries) {
        break;
      }

      // Esperar antes del siguiente intento (backoff exponencial)
      const waitTime = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s
      console.log(`‚è≥ Esperando ${waitTime}ms antes del siguiente intento...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }

  // Si llegamos aqu√≠, todos los intentos fallaron
  console.error('‚ùå Todos los intentos de transcripci√≥n fallaron');
  
  // Devolver un error m√°s espec√≠fico seg√∫n el tipo de error
  if (lastError?.code === 'insufficient_quota') {
    throw new Error('Cuota de OpenAI agotada. Contacta al administrador.');
  } else if (lastError?.message?.includes('Connection')) {
    throw new Error('Error de conexi√≥n con OpenAI. Intenta nuevamente en unos minutos.');
  } else if (lastError?.status === 413) {
    throw new Error('El archivo de audio es demasiado grande.');
  } else {
    throw new Error('No pude procesar el audio despu√©s de varios intentos.');
  }
}


